# 将 js 的数据分成两种—— pull 和 push

如果把 js 的数据分成 pull 和 push 两种，那么就可以用 **collection-query** 去操作它们了！

[collection-query](https://github.com/Iplaylf2/collection-query) 是一个集合操作类库，使用它如同操作原生数组一般。它的名字也因此而来，下文简称 cq 。

## 阅读帮助

1. 这里主要是分享一下构思，cq 投入生产还缺乏考验。
2. cq 中 pull 和 push 的概念启发自 [rxjs](https://github.com/ReactiveX/rxjs) ，但 cq 和 rxjs 还是有很大不同的。~~作者没用过rxjs。~~
3. cq 是用 ts 编写的，ts 和 js 都可以用。下文主要使用 js 作例子，会有少量的 ts 代码，但不影响阅读。

## 日常的数组操作

``` javascript
// 据说变量名长度小于7便于阅读
// 统计一下全局有多少个这样的变量

const x = Object.keys(globalThis) // 获取数据的集合
  .map((x) => x.length) // 变换
  .filter((x) => x < 7) // 变换
  .reduce((r, _) => r + 1, 0); // 聚合
```
~~xx.length~~

数组的操作可以简单分为3个步骤。
1. 获取数据的集合。
2. 将集合变换为另一个集合。
3. 将集合聚合成一个值。

## 在cq中的集合操作

用 cq 复刻上一节的数组操作：

``` typescript
import { transfer } from "collection-query";
import { createFrom, map, filter, reduce } from "collection-query/pull";

const s = createFrom(Object.keys(globalThis)); // 获取数据的集合
const s2 = transfer(s, [
  // 变换
  map((x: string) => x.length),
  filter((x: number) => x < 7),
]);
const x = reduce(s2, (r, _) => r + 1, 0); // 聚合
```

从代码量和结构来看，cq 显得冗杂，而这是对环境的妥协。
- 不用链式操作，是为了 tree sharking 。
- 使用 transfer(s, [...methods]) ，是为了 ts 的类型推导。如：上文的 `const x...` 最终能推导为 number 类型。

后文将逐一展现 cq 的特点。

## pull 流

流？集合？他们其实是一样的东西，只不过用流形容 pull 和 push 比较自然。

先看一个上文用到的 pull 流的例子。

``` typescript
import { transfer } from "collection-query";
import { take, map, filter, count } from "collection-query/pull";

// 获取数据的集合；生成一个代表自然数的 pull 流
const s = function* () {
  let count = 0;
  while (true) {
    yield count++;
  }
};

// 转换；前100个数里能被3整除的数
const s2 = transfer(s, [
  take<number>(100),
  map((x: number) => x % 3),
  filter((x: number) => x === 0),
]);

// 聚合；求元素的个数
const x = count(s2);

```

