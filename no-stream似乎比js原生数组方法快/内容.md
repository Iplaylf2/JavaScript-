# no-stream似乎比js原生数组方法快

- [no-stream](#no-stream)
- [用 benchmark 测试吧](#用-benchmark-测试吧)
  - [测试结果](#测试结果)
  - [比原生数组方法更快！](#比原生数组方法更快)
  - [在本地进行测试](#在本地进行测试)
- [没有魔法](#没有魔法)
  - [只遍历1次数组](#只遍历1次数组)
  - [没有魔法](#没有魔法-1)
  - [transduce in js](#transduce-in-js)

## no-stream

[no-stream](https://github.com/Iplaylf2/no-stream) 又是一个处理集合的库，介绍他不如直接拿来和原生数组比一比。

## 用 benchmark 测试吧

> 我们平常写 js ，免不了对数组进行一些遍历操作，反馈在代码上，就是一系列的链式操作。`[...xxx].map(xxx).filter(xxx).slice(xxx)....`

> 不知觉中，我以为这些方法在js中在同样表达式中是最快的。如果是第三方更抽象的方法，我会默认它**以性能作为抽象的代价**。可是某天我发现，我能全都要。

以下是部分测试代码，它测试了，长度为100 ～ 100,000的数组经历2 ～ 5次的 map 后再 reduce ，这些情况下的 ops/sec （完成次数/秒）。

``` javascript
new Suite()
    .add("array", function () {
      let d = data;
      for (let i = 0; i !== map_count; i++) {
        d = d.map(mf);
      }
      d.reduce(rf, 0);
    })
    .add("no-stream", function () {
      let d = ns(data);
      for (let i = 0; i !== map_count; i++) {
        d = d.map(mf);
      }
      d.reduce(rf, 0);
    })
```

### 测试结果

*array*

| map times \ ops/sec \  array length | 100       | 1,000  | 10,000 | 100,000 |
| ----------------------------------- | --------- | ------ | ------ | ------- |
| 2                                   | 1,159,961 | 23,041 | 2,462  | 184     |
| 3                                   | 184,536   | 19,075 | 1,947  | 140     |
| 4                                   | 151,335   | 13,333 | 1,561  | 114     |
| 5                                   | 127,720   | 12,334 | 1,359  | 90.35   |
  
*no-stream*

| map times \ ops/sec \  array length | 100     | 1,000  | 10,000 | 10,0000 |
| ----------------------------------- | ------- | ------ | ------ | ------- |
| 2                                   | 400,500 | 45,295 | 4,820  | 481     |
| 3                                   | 276,977 | 34,394 | 3,599  | 349     |
| 4                                   | 216,729 | 26,527 | 2,751  | 265     |
| 5                                   | 180,349 | 22,585 | 2,199  | 224     |


### 比原生数组方法更快！

可以看出，除了数据量在 100 且 map 2次时 no-stream 比较慢，其他情况都是 no-stream 更快。并且随着数据规模和转换次数的增长，no-stream 会比 array 快更多！

### 在本地进行测试

``` bash
git clone https://github.com/Iplaylf2/no-stream.git
cd no-stream
npm run init
npm run init-debug
npm run benchmark
```

## 没有魔法

为什么 no-stream 会更快？这其中没有用到什么黑科技，也没有魔法般的技艺，仅仅是 no-stream 只遍历了1次数组。

### 只遍历1次数组

以下有两段代码，s 是 Array 的一个实例。

*a*
``` javascript
s.map(aa).map(bb).forEach(cc);
```

*b*
``` javascript
for (var x of s) {
  x = aa(x);
  x = bb(x);
  cc(x);
}
```

他们做的事情是一样的，但是 *b* 版本会更快。原因如下。

- *a* 总共遍历3次，*b* 只遍历了1次。每次遍历的子过程，都会有边界判断。
- *a* 会产生中间数组，会开辟更多的内存空间。

### 没有魔法

no-stream 很普通，它还没学会怎么把链式调用的代码转化为一个循环，用来解决所有数据遍历的问题。

它底层的底层用到的是 transduce 的变体。

transduce 想法是把集合的一系列转换（transform）方法，预处理压缩为1个转换方法，然后在消费时（reduce）只遍历1次数据只做1次转换。

把层层遍历，变成1次遍历中的层层转换。就好像是中间件。

> transform，reduce，中间件这几个形容都是从[Isaac的博客](http://gfzeng.github.io/blog/2017/06/27/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-transducer/)偷过来的

为什么是 transduce 的变体？因为 transduce 是我从 [clojure](https://clojure.org/reference/transducers) 偷过来的，没有按照它既定的实现，只是按其思想因地制宜在 js 实现了不一样的东西。~~说起来它应该叫 transducer，我甚至连名字都抄错了。~~

### transduce in js
