# JavaScript的环境模型

《SICP》提到了环境模型(Environment  Model)这一个概念，它用于解释Scheme函数的计算规则。同样，它也适用于JavaScript函数的计算规则。

- [环境是什么](#环境是什么)
- [环境模型](#环境模型)
    - [变量环境](#变量环境)
        - [环境的生命周期](#环境的生命周期)
    - [变量约束](#变量约束)
        - [约束变量和自由变量](#约束变量和自由变量)
        - [环境中的变量约束](#环境中的变量约束)
    - [环境引用](#环境引用)
- [模拟环境模型](#模拟环境模型)
- [验证环境模型](#验证环境模型)

## 环境是什么

节选《SICP》 3.2  The Environment Model of Evaluation

> The environment is crucial to the evaluation process, because it determines the context in which an
expression should be evaluated.
Indeed, one could say that expressions in a programming language do not,in themselves, have any meaning. Rather, an expression acquires a meaning only with respect to some environment in which it is evaluated. Even the interpretation of an expression as straightforward as (+ 1 1) depends on an understanding that one is operating in a context in which + is the symbol for addition.

翻译
> 环境在计算过程必不可少，因为它决定了计算表达式的上下文。
可以这样认为，表达式本身在程序语言里毫无意义，表达式的意义取决于它计算时所在的环境。就算是`(+ 1 1)`这一条极其简单的表达式，也需要在符号+表示加法的上下文里才能进行计算。

JavaScript的解释器就充当着环境的角色。在该环境下，表达式`1 + 1`的计算结果为2，表达式`Date()`调用一个函数并返回当前的时间，表达式`() => 1`定义了一个返回1的函数……总之，对于程序而言，环境就是在计算过程为符号提供实际意义的东西。

## 环境模型

### 变量环境

环境模型中的环境具体指的是变量环境。函数在计算时，会根据**环境**决定变量的值，从而决定函数的计算结果。

#### 环境的生命周期

程序在调用函数时会先创建一个环境，然后在该环境中计算函数的内容。当函数中的变量不再需要解释时，环境就会被销毁。

```JavaScript
function add10(value) { //1
    var increment = 10; //2
    return value + increment;   //3
}   //4
add10(2);   //5
```

表达式`add10(2)`的计算过程：
1. 创建环境\$add10。（行5）
2. 给环境\$add10中的变量*value*赋值2。（行5）
3. 进入函数*add10*。
4. 进入环境\$add10。
5. 在环境\$add10中，给变量*increment*赋值10。（行2）
6. 在环境\$add10中，获得变量*value*的值2。（行3）
7. 在环境\$add10中，获得变量*increment*的值10。（行3）
8. 计算表达式`2 + 10`得到12。（行3）
9. 返回12。（行3）
10. 离开函数*add10*。
11. 离开环境\$add10。
12. 销毁环境\$add10。

*值得一提的是，形参也是变量，它在形参列表里定义，在函数调用时获得初始值。*

### 变量约束

#### 约束变量和自由变量

在函数中定义一个变量，变量的意义取决于函数的内容，它的作用范围也被约束在函数之中，此时的变量被称为**约束变量**。

在函数中使用一个没有定义的变量，它的作用范围不受函数的约束，此时的变量被称为**自由变量**。

```JavaScript
function main() {   //1
    var x = 10; //2
    var addX = function (value) {   //3
        var increment = x;  //4
        return value + increment;   //5
    };  //6

    var value = 2;  //7
    addX(value);    //8
}   //9
main(); //10
```

- 在函数*main*中，变量*x*，*addX*，*value*皆为约束变量。
- 在函数*addX*中，变量*value*，*increment*是约束变量，变量*x*是自由变量。

#### 环境中的变量约束

计算函数时，函数中的变量定义会使当前环境加入对应的**变量约束**，环境使用变量约束来存放变量的值。

表达式`main()`的计算过程创建了2个环境，\$main和\$addX：
- 环境\$main拥有3个变量约束，\*x，\*addX，\*value。
- 环境\$addX拥有2个变量约束，\*value，\*increment。

*为了简化模型，变量约束是在创建环境时就加入环境，而不是在计算变量定义的表达式时才动态加入环境。故上文称环境拥有变量约束。*

显然，变量约束存放的是约束变量的值，约束变量的值可以从当前环境获取。但一个自由变量需要得到解释时，则需要通过其他环境来解释，在那个环境中，该变量属于约束变量。

表达式`addX(value)`的计算过程访问了7次变量约束：
1. 获得环境\$main中变量约束\*addX的值addX函数。（行8）
2. 获得环境\$main中变量约束\*value的值2。（行8）
3. 修改环境\$addX中变量约束\*value的值为2。（行8）
4. 获得环境\$main中变量约束\*x的的值10。（行4）
5. 修改环境\$addX中变量约束\*increment的值为10。（行4）
6. 获得环境\$addX中变量约束\*value的值2。（行5）
7. 获得环境\$addX中变量约束\*increment的值10。（行5）

*计算function表达式或lambda表达式会得到一个函数，这种情况一般被称为函数定义。方便起见，本文将值是变量的函数称为函数。*

就这样，程序在计算函数时，只要找到对应的变量约束，就能确定一个变量的值。

### 环境引用



## 模拟环境模型

## 验证环境模型