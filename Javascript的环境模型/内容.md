# JavaScript的环境模型

《SICP》提到了 **环境模型（Environment  Model）** 这一个概念，它用于解释Scheme的函数计算规则。同样，它也适用于JavaScript的函数计算规则。

- [环境是什么](#环境是什么)
- [环境模型](#环境模型)
  - [变量环境](#变量环境)
    - [环境的创建和作用](#环境的创建和作用)
  - [变量绑定](#变量绑定)
    - [约束变量和自由变量](#约束变量和自由变量)
    - [绑定与变量](#绑定与变量)
  - [环境引用](#环境引用)
    - [环境引用的来源](#环境引用的来源)
    - [环境引用与绑定](#环境引用与绑定)
  - [总结](#总结)
- [模拟环境模型](#模拟环境模型)
  - [class Environment](#class-environment)
  - [bindingContainer member](#bindingcontainer-member)
  - [defineVariable method](#definevariable-method)
  - [environmentPointer member](#environmentpointer-member)
  - [findBindingContainer method](#findbindingcontainer-method)
  - [Environment.End member](#environmentend-member)
  - [getVariable method](#getvariable-method)
  - [setVariable method](#setvariable-method)
  - [class $Function](#class-function)
  - [Environment constructor](#environment-constructor)
- [验证环境模型](#验证环境模型)
  - [环境模型的优化](#环境模型的优化)

## 环境是什么

节选《SICP》 3.2  The Environment Model of Evaluation

> The environment is crucial to the evaluation process, because it determines the context in which an
expression should be evaluated.
Indeed, one could say that expressions in a programming language do not,in themselves, have any meaning. Rather, an expression acquires a meaning only with respect to some environment in which it is evaluated. Even the interpretation of an expression as straightforward as (+ 1 1) depends on an understanding that one is operating in a context in which + is the symbol for addition.

翻译

> 环境在计算过程必不可少，因为它决定了计算表达式的上下文。
可以这样认为，表达式本身在程序语言里毫无意义，表达式的意义取决于它计算时所在的环境。就算是`(+ 1 1)`这一条极其简单的表达式，也需要在符号+表示加法的上下文里才能进行计算。

JavaScript的解释器就充当着环境的角色。在该环境下，表达式`1 + 1`的计算结果为2，表达式`Date()`调用一个函数并返回当前的时间，表达式`() => 1`定义了一个返回1的函数……总之，对程序而言，环境就是在计算过程为符号提供实际意义的东西。

## 环境模型

### 变量环境

环境模型中的环境具体指的是变量环境。函数在计算时会根据 **环境（environment）** 决定变量的值，从而决定它的计算结果。

#### 环境的创建和作用

函数在调用时会先创建一个环境，然后在该环境中计算函数的内容。

```JavaScript
function add10(value) { //1
    var increment = 10; //2
    return value + increment;   //3
}   //4
add10(2);   //5
```

表达式`add10(2)`（行5）的计算过程：
1. 创建环境\$add10。（行5）
2. 给环境\$add10中的变量*value*赋值2。（行5）
3. 进入环境\$add10。
4. 在环境\$add10中，给变量*increment*赋值10。（行2）
5. 在环境\$add10中，获得变量*value*的值2。（行3）
6. 在环境\$add10中，获得变量*increment*的值10。（行3）
7. 计算表达式`2 + 10`得到12。（行3）
8. 返回12。（行3）
9.  离开环境\$add10。

*值得一提的是，形参也是变量，它在形参列表里定义，在函数调用时获得初始值。*

### 变量绑定

环境使用变量绑定来存放变量的值， **绑定（binding）** 与函数中的变量一一对应。

#### 约束变量和自由变量

在函数中定义一个变量，变量的意义取决于函数的内容，它的作用范围也被约束在函数之中，此时的变量被称为 **约束变量（bound variable）** 。

在函数中使用一个没有定义的变量，它的作用范围不受函数的约束，此时的变量被称为 **自由变量（free variable）** 。

```JavaScript
function main() {   //1
    var x = 10; //2
    var addX = function (value) {   //3
        var increment = x;  //4
        return value + increment;   //5
    };  //6

    var value = 2;  //7
    addX(value);    //8
}   //9
main(); //10
```

var关键字可以定义变量：
- 在函数*main*中，变量*x*（行2、4），*addX*（行3、8），*value*（行7、8）皆为约束变量。
- 在函数*addX*中，变量*value*（行3、5），*increment*（行4、5）是约束变量，变量*x*（行4）是自由变量。

#### 绑定与变量

在函数的计算过程中，变量定义会使当前的环境加入对应的绑定。

上文中表达式`main()`（行10）的计算过程产生了2个环境，\$main和\$addX：
- 环境\$main拥有3个绑定，\*x，\*addX，\*value。
- 环境\$addX拥有2个绑定，\*value，\*increment。

可见，绑定存放的是约束变量的值，约束变量的值可以直接从当前环境获取。  
而自由变量的值需要从其他环境获取，该环境是自由变量定义时所在的环境，拥有自由变量的绑定。

上文中表达式`addX(value)`（行8）的计算过程：
1. 获得环境\$main中绑定\*addX的值addX函数。（行8）
2. 获得环境\$main中绑定\*value的值2。（行8）
3. 修改环境\$addX中绑定\*value的值为2。（行8）
4. 获得环境\$main中绑定\*x的的值10。（行4）
5. 修改环境\$addX中绑定\*increment的值为10。（行4）
6. 获得环境\$addX中绑定\*value的值2。（行5）
7. 获得环境\$addX中绑定\*increment的值10。（行5）

*计算function表达式或lambda表达式会得到一个函数，这种情况一般被称为函数定义。方便起见，本文将值是变量的函数称为函数。*

就这样，函数在计算时只要找到对应的绑定，就能确定一个变量的值。

### 环境引用

环境不仅保存了变量绑定，还会保存一个 **环境引用（environment pointer）** ，环境引用指向其他的变量环境。通过环境引用，自由变量可以从其他环境寻找自己对应的绑定。

#### 环境引用的来源

函数在定义时会把当前环境的引用记录下来。在调用函数后，新的环境会得到函数中的环境引用并将此保存。  
也就是说，一个函数在计算时的环境，拥有函数在定义时的环境的引用。

```JavaScript
var getCounter = function (start) { //1
    return function () {    //2
        return start++; //3
    };  //4
};  //5
var counter = getCounter(0);    //6
counter();  //7
```

表达式`getCounter(0)`（行6）和`counter()`（行7）分别创建了两个环境：
- 环境\$getCounter拥有全局环境的引用。
- 环境\$counter拥有环境\$getCounter的引用。

*一些看似不在函数中定义的函数，其定义时也身处环境中，该环境被称为全局环境。函数getCounter就保存了全局环境的引用。*

#### 环境引用与绑定

函数在计算过程中定义函数，如同代码文本结构那样一层包裹一层，里层的函数定义是外层函数中的一条表达式，里层函数创建的环境通过引用连接外层函数创建的环境。  
因此，一个变量在当前环境找不到对应的绑定时，可以通过引用一层层回溯到它定义时所在的环境，从而找到该绑定。自由变量便是通过这种方法找到自己对应的绑定。

上文中表达式`counter()`（行7）的计算过程：
1. 使用变量*counter*。（行7)
2. 在当前环境（全局环境）找到变量绑定\*counter，它的值是一个函数 。
3. 调用函数*counter*会创建环境\$counter。（行7）
4. 环境\$counter从函数*counter*得到环境\$getCounter的引用。
5. 进入环境\$counter。
6. 使用变量start。（行3）
7. 在环境\$counter找不到绑定\*start。
8. 环境\$counter通过引用定位到环境\$getCounter。
9. 在环境\$getCounter中找到绑定\*start。
10. 返回绑定\*start的值0作为函数的计算结果。（行3）
11. 令绑定\*start的值自增1，从0变为1。（行3）
12. 离开环境\$counter。
  
*每次计算表达式`counter()`，绑定\*start的值都会自增1，并依次返回0,1,2,3……*

### 总结

函数在定义时会保存当前 **环境** 的 **引用** 。  
一旦函数被调用，就会创建一个新的环境，新的环境拥有函数定义时环境的引用。  
函数中的变量定义表达式会给新环境加入 **绑定** 。  
函数使用变量就是访问环境中对应的绑定。  
如果变量在当前环境找不到对应的绑定，就会通过引用一层层回溯到它定义时所在环境，从而找到它的绑定。  
而这种访问其他变量环境的机制，通常被人称为 **闭包** 。

## 模拟环境模型

下文将讲述，如何用js模拟环境模型。在这个模拟环境模型中，不需要定义变量也能使用闭包。  

主要模拟的角色是环境，不是函数。模拟函数太过复杂了。  
首先，为了让js函数能使用环境解释变量，环境将作为函数的参数：
```JavaScript
function $func($){
    //$是$func调用时创建的环境。
};
```
就这样，每次函数被调用时，被创建的环境都会作为参数传进。  

### class Environment

函数通过环境使用变量，环境应有getVariable和setVariable方法。  
变量在使用前要有定义，环境应有defineVariable方法。  
此外，函数在定义时会保存当前环境的引用，环境应有defineFunction方法。  
因此，代表环境的class是这样的：
```JavaScript
class Environment {
    //变量定义
    defineVariable(name) {
    }
    //变量取值
    getVariable(name) {
    }
    //变量赋值
    setVariable(name, value) {
    }
    //函数定义
    defineFunction($func) {
    }
}
```

### bindingContainer member

环境可以看作是变量（绑定）的容器，应有一个bindingContainer成员用来存放变量。  
考虑到前端js的全局变量可以在window对象上找到，bindingContainer使用Object类型的对象的话，可以与window[name]同样的形式bindingContainer[name]访问变量。  
因此，定义、取值、赋值可以表达为：
```JavaScript
this.bindingContainer[name] = null; //定义
value = this.bindingContainer[name];    //取值
this.bindingContainer[name] = value;    //赋值
```

### defineVariable method

Environment的defineVariable方法实现很直接，为当前环境加入绑定:
```JavaScript
defineVariable(name) {
    this.bindingContainer[name] = null;
}
```

### environmentPointer member

在当前环境使用的变量，绑定有可能在别的环境中，应有一个代表环境引用的成员environmentPointer。  
且environmentPointer是Environment类型。

### findBindingContainer method

取值和赋值都需要找到变量的绑定，应有一个共同的方法findBindingContainer用来查找绑定。  
为了方便赋值进行，方法返回的是绑定的容器。  
变量在当前环境找不到绑定时，会通过引用向上一层环境查找。这是递归的，因此findBindingContainer的表达为：
```JavaScript
findBindingContainer(variable_name) {
    //判断当前环境是否存在绑定。
    if (this.bindingContainer.hasOwnProperty(variable_name)) {
        //找到了绑定，返回绑定的容器。
        return this.bindingContainer;
    } else {
        //在该环境中找不到绑定。
        //判断引用是否达到了尽头。
        if (this.environmentPointer === Environment.End) {
            //环境引用走到了尽头，抛出异常。
            throw '不存在对应的绑定。';
        } else {
            //通过环境引用在上一层环境中查找绑定。
            return this.environmentPointer.findBindingContainer(variable_name);
        }
    }
}
```
*Object类型的对象自带hasOwnProperty方法判断自己是否拥有某个成员。*

### Environment.End member

显然，通过引用一直向上遍历环境是有尽头的，在这里规定环境的尽头Environment.End为null：
```JavaScript
Environment.End = null;
```

### getVariable method

有了findBindingContainer方法，便能轻易写出getVariable方法：
```JavaScript
getVariable(name) {
    var binding_container = this.findBindingContainer(name);
    var value = binding_container[name];
    return value;
}
```

### setVariable method

同上，setVariable方法的表达为：
```JavaScript
setVariable(name, value) {
    var binding_container = this.findBindingContainer(name);
    binding_container[name] = value;
}
```

### class $Function

环境还需要实现一个定义函数的方法，模拟函数定义太过复杂。

### Environment constructor

至此，先补充一下Environment的构造方法，环境引用在构造时传进：
```JavaScript
constructor(pointer) {
    this.environmentPointer = pointer;
    this.bindingContainer = {};
}
```

## 验证环境模型

### 环境模型的优化