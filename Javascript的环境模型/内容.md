# JavaScript的环境模型

《SICP》提到了 **环境模型（Environment  Model）** 这一个概念，它用于解释Scheme函数的计算规则。同样，它也适用于JavaScript函数的计算规则。

- [环境是什么](#环境是什么)
- [环境模型](#环境模型)
    - [变量环境](#变量环境)
        - [环境的生命周期](#环境的生命周期)
    - [变量绑定](#变量绑定)
        - [约束变量和自由变量](#约束变量和自由变量)
        - [环境中的绑定](#环境中的绑定)
    - [环境引用](#环境引用)
        - [环境引用的来源](#环境引用的来源)
        - [环境引用与自由变量](#环境引用与自由变量)
    - [环境的回收](#环境的回收)
    - [总结](#总结)
- [模拟环境模型](#模拟环境模型)
- [验证环境模型](#验证环境模型)
    - [环境模型的优化](#环境模型的优化)

## 环境是什么

节选《SICP》 3.2  The Environment Model of Evaluation

> The environment is crucial to the evaluation process, because it determines the context in which an
expression should be evaluated.
Indeed, one could say that expressions in a programming language do not,in themselves, have any meaning. Rather, an expression acquires a meaning only with respect to some environment in which it is evaluated. Even the interpretation of an expression as straightforward as (+ 1 1) depends on an understanding that one is operating in a context in which + is the symbol for addition.

翻译

> 环境在计算过程必不可少，因为它决定了计算表达式的上下文。
可以这样认为，表达式本身在程序语言里毫无意义，表达式的意义取决于它计算时所在的环境。就算是`(+ 1 1)`这一条极其简单的表达式，也需要在符号+表示加法的上下文里才能进行计算。

JavaScript的解释器就充当着环境的角色。在该环境下，表达式`1 + 1`的计算结果为2，表达式`Date()`调用一个函数并返回当前的时间，表达式`() => 1`定义了一个返回1的函数……总之，对于程序而言，环境就是在计算过程为符号提供实际意义的东西。

## 环境模型

### 变量环境

环境模型中的环境具体指的是变量环境。函数在计算时，会根据 **环境（environment）** 决定变量的值，从而决定函数的计算结果。

#### 环境的生命周期

程序在调用函数时会先创建一个环境，然后在该环境中计算函数的内容。当函数中的变量不再需要解释时，环境就会被销毁。

```JavaScript
function add10(value) { //1
    var increment = 10; //2
    return value + increment;   //3
}   //4
add10(2);   //5
```

表达式`add10(2)`的计算过程：
1. 创建环境\$add10。（行5）
2. 给环境\$add10中的变量*value*赋值2。（行5）
3. 进入函数*add10*。
4. 进入环境\$add10。
5. 在环境\$add10中，给变量*increment*赋值10。（行2）
6. 在环境\$add10中，获得变量*value*的值2。（行3）
7. 在环境\$add10中，获得变量*increment*的值10。（行3）
8. 计算表达式`2 + 10`得到12。（行3）
9. 返回12。（行3）
10. 离开函数*add10*。
11. 离开环境\$add10。
12. 销毁环境\$add10。

*值得一提的是，形参也是变量，它在形参列表里定义，在函数调用时获得初始值。*

### 变量绑定

#### 约束变量和自由变量

在函数中定义一个变量，变量的意义取决于函数的内容，它的作用范围也被约束在函数之中，此时的变量被称为 **约束变量（bound variable）** 。

在函数中使用一个没有定义的变量，它的作用范围不受该函数的约束，此时的变量被称为 **自由变量（free variable）** 。

```JavaScript
function main() {   //1
    var x = 10; //2
    var addX = function (value) {   //3
        var increment = x;  //4
        return value + increment;   //5
    };  //6

    var value = 2;  //7
    addX(value);    //8
}   //9
main(); //10
```

- 在函数*main*中，变量*x*，*addX*，*value*皆为约束变量。
- 在函数*addX*中，变量*value*，*increment*是约束变量，变量*x*是自由变量。

#### 环境中的绑定

计算函数时，函数中的变量定义会使当前环境加入变量的 **绑定（binding）** ，环境使用绑定来存放变量的值。

上文中表达式`main()`的计算过程产生了2个环境，\$main和\$addX：
- 环境\$main拥有3个绑定，\*x，\*addX，\*value。
- 环境\$addX拥有2个绑定，\*value，\*increment。

*为了简化模型，绑定是在创建环境时就加入环境，而不是在计算变量定义的表达式时才动态加入环境。故上文称环境拥有绑定。*

显然，绑定存放的是约束变量的值，约束变量的值可以直接从当前环境获取。而自由变量的值则需要从其他环境获取，该环境是自由变量定义时所在的环境，拥有自由变量的绑定，

上文中表达式`addX(value)`的计算过程访问了7次绑定：
1. 获得环境\$main中绑定\*addX的值addX函数。（行8）
2. 获得环境\$main中绑定\*value的值2。（行8）
3. 修改环境\$addX中绑定\*value的值为2。（行8）
4. 获得环境\$main中绑定\*x的的值10。（行4）
5. 修改环境\$addX中绑定\*increment的值为10。（行4）
6. 获得环境\$addX中绑定\*value的值2。（行5）
7. 获得环境\$addX中绑定\*increment的值10。（行5）

*计算function表达式或lambda表达式会得到一个函数，这种情况一般被称为函数定义。方便起见，本文将值是变量的函数称为函数。*

就这样，程序在计算函数时，只要找到对应的绑定，就能确定一个变量的值。

### 环境引用

环境不仅保存了变量绑定，还会保存一个 **环境引用（environment pointer）** ，环境引用指向其他的变量环境。自由变量通过环境引用寻找自己定义时所在的环境，从而找到它对应的绑定。

#### 环境引用的来源

在环境中定义一个函数时，函数会将当前环境的引用保存下来。等到该函数被调用时，新创建的环境将会得到函数中的环境引用并将此保存。  
也就是说，一个函数在计算时的环境，拥有函数在定义时的环境的引用。

```JavaScript
var getCounter = function (start) { //1
    return function () {    //2
        return start++; //3
    };  //4
};  //5
var counter = getCounter(0);    //6
counter();  //7
```

分别由表达式`getCounter(0)`和`counter()`创境的环境中：
- 环境\$getCounter拥有全局环境的引用。
- 环境\$counter拥有环境\$getCounter的引用。

*一些看似不在函数中定义的函数，其定义时也身处环境中，该环境被称为全局环境。函数getCounter就保存了全局环境的引用。*

#### 环境引用与自由变量



### 环境的回收

### 总结

## 模拟环境模型

## 验证环境模型

### 环境模型的优化